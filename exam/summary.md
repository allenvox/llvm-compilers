# Summary

#### 1. **Как Clang взаимодействует с LLVM?**
Clang преобразует исходный код в LLVM IR с помощью компонента `CodeGen` и передает IR в оптимизатор LLVM.

#### 2. **Какие этапы выполняет Clang?**
1. Лексический анализ (токены).
2. Синтаксический анализ (AST).
3. Семантический анализ (проверка типов и логики).
4. Генерация LLVM IR.

#### 3. **Что такое AST в Clang?**
AST (Abstract Syntax Tree) — это дерево, которое представляет структуру программы. Оно используется для анализа и генерации кода.

#### 4. **Как Clang преобразует функцию в LLVM IR?**
Компонент `CodeGen` проходит по узлам AST, преобразуя их в соответствующие инструкции IR. Например, `ReturnStmt` преобразуется в `ret` с помощью `llvm::IRBuilder`.

#### 5. **Какие инструменты предоставляет Clang?**
- `clang` — компилятор.
- `LibTooling` — для разработки инструментов.
- `Clang-Tidy` — для статического анализа.

#### 6. **Какие вызовы в коде Clang генерируют IR?**
- `CodeGenFunction::EmitBinaryOperator` — генерирует арифметические операции.
- `CodeGenFunction::EmitReturnStmt` — генерирует инструкцию `ret`.

#### 7. **Что такое LLVM IR и зачем оно используется?**
- LLVM IR — это промежуточное представление программы, используемое для анализа, оптимизации и генерации машинного кода. Оно обеспечивает платформонезависимость и строгую типизацию.

#### 8. **Какие типы данных поддерживает LLVM IR?**
- Примитивные (`i32`, `float`), агрегатные (`array`, `struct`), указатели (`i32*`), функции (`i32 (i32, i32)`).

#### 9. **Что такое базовый блок в LLVM IR?**
- Базовый блок — это последовательность инструкций, которая выполняется линейно. Каждый блок заканчивается инструкцией управления потоком.

#### 10. **Как работают PHI-функции?**
- PHI-функции используются для выбора значения переменной в зависимости от пути выполнения программы в SSA.

#### 11. **Как в LLVM IR реализуются циклы?**
- Циклы состоят из базового блока для проверки условия (`loop`), тела цикла (`body`) и блока завершения (`end`), с использованием условных переходов (`br`).

#### 12. **Почему LLVM IR использует SSA?**
- SSA облегчает анализ кода и упрощает оптимизации, такие как удаление мертвого кода и распространение констант.

#### 13. **Как в LLVM IR реализуются условные переходы?**
- Используются инструкции `icmp` / `fcmp` для сравнения значений и `br` для ветвления.

#### 14. **Чем отличается цикл `for` от `while` в LLVM IR?**
- Цикл `for` включает явную инициализацию и инкремент, которые могут быть вынесены в отдельные базовые блоки. В `while` проверка условия всегда выполняется перед началом цикла.

#### 15. **Что такое PHI-функция и зачем она используется?**
- PHI-функция объединяет значения переменной из разных путей выполнения. Она выбирает значение в зависимости от того, из какого блока пришел поток управления.

#### 16. **Какие инструкции используются для реализации базовых блоков?**
- `br` (безусловный или условный переход) и инструкции ветвления, такие как `icmp` / `fcmp`.

#### 17. **Как в LLVM IR обрабатывается тело цикла?**
- Тело цикла всегда находится в отдельном базовом блоке (`loop_body`), выполнение которого заканчивается переходом к блоку проверки условия.

#### 18. **Как в LLVM IR объявляется массив?**
- Используется тип `array [N x <type>]`. Например, `[5 x i32]` для массива из 5 элементов типа `i32`.

#### 19. **Как получить доступ к элементу массива?**
- Используется инструкция `getelementptr` для вычисления указателя на элемент.

#### 20. **Как работают локальные массивы?**
- Выделяются с помощью `alloca`, после чего используются операции `getelementptr`, `load` и `store`.

#### 21. **Как передаются массивы в функции?**
- Обычно массив передается по указателю (например, `i32*` для массива из элементов `i32`).

#### 22. **Как в LLVM IR реализуются многомерные массивы?**
- Многомерные массивы представляются как вложенные одномерные массивы.

#### 23. **Как в LLVM IR выделяются локальные переменные?**
- Локальные переменные выделяются с помощью инструкции `alloca`, которая создает блок памяти на стеке.

#### 24. **Как в LLVM IR работают с глобальными переменными?**
- Глобальные переменные задаются с атрибутом `global` и имеют фиксированное место в памяти.

#### 25. **Как передаются параметры функций в LLVM IR?**
- Параметры передаются через регистры, но могут быть сохранены в стек с помощью `alloca`.

#### 26. **Какие отличия между стековыми и глобальными переменными?**
- Стековые переменные существуют только в рамках функции, глобальные переменные доступны из любой функции модуля.

#### 27. **Как осуществляется доступ к массивам в LLVM IR?**
- Используется инструкция `getelementptr` для вычисления адреса элемента массива, затем операции `load` и `store` для работы с памятью.

#### 28. **Как объявить структуру в LLVM IR?**
- Через тип `type`, например: `%struct.MyStruct = type { i32, float }`.

#### 29. **Как получить доступ к полю структуры?**
- Используется инструкция `getelementptr`, чтобы вычислить адрес нужного поля.

#### 30. **Как в LLVM IR инициализируется структура?**
- Через список значений: `{ i32 42, float 3.14 }` или `zeroinitializer`.

#### 31. **Как передать структуру в функцию?**
- По значению: `%struct.MyStruct` как параметр.
- По указателю: `%struct.MyStruct*`.

#### 32. **Как вернуть структуру из функции?**
- Через копирование структуры в значение, возвращаемое функцией.

#### 33. **Как работает массив структур в LLVM IR?**
- Массив структур объявляется как `[N x %struct.MyStruct]`.

#### 34. **Как классы транслируются в LLVM IR?**
- Классы транслируются в структуры (`type`), где поля представляют члены класса, а методы — функции, принимающие `this`.

#### 35. **Как реализуется доступ к членам класса?**
- С помощью `getelementptr` для вычисления адреса поля в памяти.

#### 36. **Как реализуется полиморфизм?**
- Через виртуальные таблицы (`vtable`), в которых хранятся указатели на виртуальные функции.

#### 37. **Как передаются методы-члены в LLVM IR?**
- Методы-члены транслируются как функции, где `this` передается первым аргументом.

#### 38. **Как работают шаблоны классов?**
- Шаблоны транслируются как отдельные структуры для каждого конкретного типа.

#### 39. **Как реализуется наследование в LLVM IR?**
- Наследование транслируется через вложенные структуры: дочерний класс включает базовый класс как первое поле.

#### 40. **Что такое vtable, и как она используется?**
- vtable — это таблица указателей на виртуальные функции. Она используется для динамической диспетчеризации методов.

#### 41. **Как осуществляется вызов виртуальных функций?**
- Указатель на функцию извлекается из vtable, и затем происходит вызов через `call`.

#### 42. **Как работает `dynamic_cast`?**
- `dynamic_cast` проверяет vtable объекта, чтобы определить, соответствует ли объект целевому типу.

#### 43. **Как LLVM IR обрабатывает множественное наследование?**
- Класс с множественным наследованием содержит указатели на vtable для каждого базового класса.

#### 44. **Какие инструкции LLVM IR используются для обработки исключений?**
- Основные инструкции: `invoke`, `landingpad`, `resume`.

#### 45. **Что делает инструкция `invoke`?**
- Выполняет вызов функции с возможностью обработки исключений. В случае исключения управление передается в указанный `landingpad`.

#### 46. **Как в LLVM IR работает инструкция `landingpad`?**
- Перехватывает исключения и возвращает данные исключения и его тип.

#### 47. **Как передать исключение дальше?**
- Используется инструкция `resume`.

#### 48. **Что такое таблицы исключений?**
- Это метаданные, содержащие информацию о типах исключений и блоках `catch`.

#### 49. **Как в LLVM IR реализуется `throw`?**
- Исключение создается через `__cxa_allocate_exception` и выбрасывается через `__cxa_throw`.

#### 50. **Как генерируется информация DWARF в LLVM IR?**
- С помощью метаданных, таких как `DICompileUnit`, `DISubprogram`, `DILocation`.

#### 51. **Какая инструкция связывает переменные с отладочной информацией?**
- `@llvm.dbg.declare` и `@llvm.dbg.value`.

#### 52. **Как генерируется DWARF для функций?**
- Через метаданные `DISubprogram` и `DILocation`.

#### 53. **Как скомпилировать код с DWARF с помощью Clang?**
- Использовать флаг `-g`.

#### 54. **Что происходит с DWARF при оптимизациях?**
- Оптимизации могут изменить выполнение программы, но отладочные метки помогают сохранить связь с исходным кодом.

#### 55. **Что делает PPProfiler?**
- Инструментирует каждую функцию, добавляя вызовы `__ppp_enter` и `__ppp_exit` для регистрации входа и выхода.

#### 56. **Как реализуется вызов `__ppp_enter` и `__ppp_exit`?**
- Через инструкции `call`, добавляемые в начале функции и перед `ret`.

#### 57. **Как передается имя функции в `__ppp_enter`?**
- Используется глобальная строка (`getelementptr`) с именем функции.

#### 58. **Что делает `run` в проходе?**
- Анализирует модуль, добавляет объявления `__ppp_enter` и `__ppp_exit`, затем инструментирует каждую функцию.

#### 59. **Как подключить плагин в LLVM?**
- Плагин регистрируется через `PassPluginLibraryInfo` и `PassBuilder`.

#### 60. **Какие оптимизации сохраняет проход?**
- Поскольку проход модифицирует IR, `PreservedAnalyses` возвращает `none`.

#### 61. **Что такое TableGen?**
- Это декларативный язык для описания данных, используемых в компиляторах LLVM.

#### 62. **Для чего используется TableGen?**
- Для описания инструкций, регистров, типов данных, сообщений диагностики и других элементов компилятора.

#### 63. **Как работают классы и определения в TableGen?**
- Классы задают шаблоны, а определения создают конкретные экземпляры с данными.

#### 64. **Как генерировать код из TableGen?**
- С помощью `llvm-tblgen` и соответствующих флагов (`-gen-instr-info`, `-gen-register-info` и т.д.).

#### 65. **Где используется TableGen в LLVM?**
- В описании целевых архитектур, селекторов инструкций, ABI, диагностики и других компонентов.

#### 66. **Можно ли использовать множественное наследование в TableGen?**
- Да, это поддерживается.

#### 67. **Что такое Orc JIT?**
- Это фреймворк для динамической компиляции и выполнения кода в реальном времени.

#### 68. **Какие компоненты входят в Orc JIT?**
- `ExecutionSession`, `JITDylib`, `IRLayer`, `ObjectLayer`, `SymbolResolver`.

#### 69. **Как добавлять LLVM IR в Orc JIT?**
- С помощью `addIRModule(ThreadSafeModule)`.

#### 70. **Как вызываются функции, скомпилированные через JIT?**
- Символ функции разрешается через `lookup`, после чего он преобразуется в указатель на функцию.

#### 71. **Можно ли использовать пользовательские функции с Orc JIT?**
- Да, через `absoluteSymbols`.

#### 72. **Что делает `CompileOnDemandLayer`?**
- Компилирует функции только при их вызове.
